using gold.**

toSet(C) :=  {x|  x in C}

///====   mini Parser===

function createParser(A):IPushdownAutomaton begin
	Q:=(0‥20)
	Σ:=toSet(A)  ∪ {' ', '\n'}
	Γ:={'$'} ∪ toSet(A)
	q₀:=0
	F:= {0}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)
	SkipChars := {' ', '\n'}   // this will only  be used when testing only the parser as the lexer removes  SkipChars

	// 6%v,v,v;[v(v,v){@(v);@(v);w(v)}][v(){8(C(O,#))<{w(O,#)}>}][v(){i(C(O,#)){w(O,#)}f}]{v(#,#);v=#;v(#,#)}9

	// 6%v;[v(v,v)9


	// Transitions

	M.delta(0,1,'6').push("$") // PROG

	// VARIABLES

	M.delta(1,1, '%').changeTop("$", "$;v")
	M.delta(1,1, 'v').pop("v")
	M.delta(1,1, ',').changeTop("$;", "$;v")
	M.delta(1,2, ';').pop(";")

	// PROCEDURES

	M.delta(2,2,'[').push("(v")
	M.delta(2,2,'v').pop("v")
	M.delta(2,3,'(').changeTop("$(", "$(v")
	M.delta(2,4,'(').ignore()

	// PROCEDURE PARAMETERS

	M.delta(3,3,'v').pop("v")
	M.delta(3,3,',').changeTop("$(", "$(v")
	M.delta(3,4,')').pop("(")

	M.delta(4,4,')').changeTop("$(", "$")

	M.delta(4,5,'{').push("}")
	M.delta(4,5,'{').changeTop("$}iC", "$}i}")

	// PROCEDURE BODY

	M.delta(5,6,'@').push(")#(")
	M.delta(5,6,'@').push(")v(")
	M.delta(5,7,'j').push(")#,#(")
	M.delta(5,7,'j').push(")v,#(")
	M.delta(5,7,'j').push(")#,v(")
	M.delta(5,7,'j').push(")v,v(")
	M.delta(5,8,'V').push(")L(")
	M.delta(5,8,'V').push(")R(")
	M.delta(5,8,'V').push(")A(")
	M.delta(5,9,'l').push(")O(")
	M.delta(5,10,'v').push("#=")

	// walk(n)
	M.delta(5,6,'w').push(")#(")
	M.delta(5,6,'w').push(")v(")
	// walk(o,n)
	M.delta(5,11,'w').push(")#,O(")
	M.delta(5,11,'w').push(")v,O(")
	// walk(d,n)
	M.delta(5,12,'w').push(")#,F(")
	M.delta(5,12,'w').push(")#,R(")
	M.delta(5,12,'w').push(")#,L(")
	M.delta(5,12,'w').push(")#,B(")
	M.delta(5,12,'w').push(")v,F(")
	M.delta(5,12,'w').push(")v,R(")
	M.delta(5,12,'w').push(")v,L(")
	M.delta(5,12,'w').push(")v,B(")


	M.delta(5,0,'}').pop("}")
	M.delta(5,18,'}').changeTop("$}i}", "$}i")

	// PROCEDURE CALL @

	M.delta(6,6,'(').pop("(")
	M.delta(6,6,'#').pop("#")
	M.delta(6,6,'v').pop("v")
	M.delta(6,6,')').pop(")")
	M.delta(6,5,';').ignore()

	// PROCEDURE CALL j

	M.delta(7,7,'(').pop("(")
	M.delta(7,7,'#').pop("#")
	M.delta(7,7,'v').pop("v")
	M.delta(7,7,',').pop(",")
	M.delta(7,7,')').pop(")")
	M.delta(7,5,';').ignore()

	// PROCEDURE CALL V

	M.delta(8,8,'(').pop("(")
	M.delta(8,8,'L').pop("L")
	M.delta(8,8,'R').pop("R")
	M.delta(8,8,'A').pop("A")
	M.delta(8,8,')').pop(")")
	M.delta(8,5,';').ignore()

	// PROCEDURE CALL l

	M.delta(9,9,'(').pop("(")
	M.delta(9,9,'O').pop("O")
	M.delta(9,9,')').pop(")")
	M.delta(9,5,';').ignore()

	// PROCEDURE CALL ASSIGNMENT

	M.delta(10,10,'=').pop("=")
	M.delta(10,10,'#').pop("#")
	M.delta(10,5,';').ignore()

	// PROCEDURE CALL walk(o,n)

	M.delta(11,11,'(').pop("(")
	M.delta(11,11,'O').pop("O")
	M.delta(11,11,',').pop(",")
	M.delta(11,11,'v').pop("v")
	M.delta(11,11,'#').pop("#")
	M.delta(11,11,')').pop(")")
	M.delta(11,5,';').ignore()

	// PROCEDURE CALL walk(d,n)

	M.delta(12,12,'(').pop("(")
	M.delta(12,12,'F').pop("F")
	M.delta(12,12,'R').pop("R")
	M.delta(12,12,'L').pop("L")
	M.delta(12,12,'B').pop("B")
	M.delta(12,12,',').pop(",")
	M.delta(12,12,'v').pop("v")
	M.delta(12,12,'#').pop("#")
	M.delta(12,12,')').pop(")")
	M.delta(12,5,';').ignore()

	// CONTROL STRUCTURES

	// IF

	M.delta(5,13,'i').push("i")

	M.delta(13,14,'(').push(")O(&")
	M.delta(13,14,'(').push("))O(&(N")

	M.delta(13,15,'(').push(")v,@(T")
	M.delta(13,15,'(').push(")#,@(T")
	M.delta(13,15,'(').push(")#,w(T")
	M.delta(13,15,'(').push(")v,w(T")
	M.delta(13,15,'(').push("))v,@(T(N")
	M.delta(13,15,'(').push("))#,@(T(N")
	M.delta(13,15,'(').push("))v,w(T(N")
	M.delta(13,15,'(').push("))#,w(T(N")

	M.delta(13,16,'(').push(")v,O(C")
	M.delta(13,16,'(').push(")#,O(C")
	M.delta(13,16,'(').push("))#,O(C(N")
	M.delta(13,16,'(').push("))v,O(C(N")

	M.delta(13,17,'(').push(")#,F(C")
	M.delta(13,17,'(').push(")#,B(C")
	M.delta(13,17,'(').push(")#,L(C")
	M.delta(13,17,'(').push(")#,R(C")
	M.delta(13,17,'(').push(")v,F(C")
	M.delta(13,17,'(').push(")v,B(C")
	M.delta(13,17,'(').push(")v,L(C")
	M.delta(13,17,'(').push(")v,R(C")
	M.delta(13,17,'(').push("))#,F(C(N")
	M.delta(13,17,'(').push("))#,B(C(N")
	M.delta(13,17,'(').push("))#,L(C(N")
	M.delta(13,17,'(').push("))#,R(C(N")
	M.delta(13,17,'(').push("))v,F(C(N")
	M.delta(13,17,'(').push("))v,B(C(N")
	M.delta(13,17,'(').push("))v,L(C(N")
	M.delta(13,17,'(').push("))v,R(C(N")

	// isFacing(O)
	M.delta(14,14,'&').pop("&")
	M.delta(14,14,'(').pop("(")
	M.delta(14,14,'N').pop("N")
	M.delta(14,14,'O').pop("O")
	M.delta(14,14,')').pop(")")
	M.delta(14,4,')').changeTop("$}i","$}iC")

	// isValid(ins,n)
	M.delta(15,15,'T').pop("T")
	M.delta(15,15,'(').pop("(")
	M.delta(15,15,'v').pop("v")
	M.delta(15,15,',').pop(",")
	M.delta(15,15,'#').pop("#")
	M.delta(15,15,')').pop(")")
	M.delta(15,15,'@').pop("@")
	M.delta(15,15,'w').pop("w")
	M.delta(15,15,'N').pop("N")
	M.delta(15,4,')').changeTop("$}i","$}iC")

	// canWalk(O,n)
	M.delta(16,16,'C').pop("C")
	M.delta(16,16,'(').pop("(")
	M.delta(16,16,'O').pop("O")
	M.delta(16,16,',').pop(",")
	M.delta(16,16,'v').pop("v")
	M.delta(16,16,'#').pop("#")
	M.delta(16,16,')').pop(")")
	M.delta(16,16,'N').pop("N")
	M.delta(16,4,')').changeTop("$}i","$}iC")

	// canWalk(d,n)
	M.delta(17,17,'C').pop("C")
	M.delta(17,17,'(').pop("(")
	M.delta(17,17,'F').pop("F")
	M.delta(17,17,'R').pop("R")
	M.delta(17,17,'L').pop("L")
	M.delta(17,17,'B').pop("B")
	M.delta(17,17,',').pop(",")
	M.delta(17,17,'v').pop("v")
	M.delta(17,17,'#').pop("#")
	M.delta(17,17,')').pop(")")
	M.delta(17,17,'N').pop("N")
	M.delta(17,4,')').changeTop("$}i","$}iC")


	// CONTROL STRUCTURES BLOCK

	// IF
	// AFTER FINISHING THE IF STATEMENT, THE CONDITION, AND THE BLOCK, THE STACK SHOULD BE LIKE THIS:
	// $}i

	M.delta(18,18,'f').pop("i")
	M.delta(18,5,';').ignore()



	M.delta(0,0,'9').pop("$") //GORP


 // this will only  be used when testing only the parser as the lexer removes  SkipChars
for each q in Q do
	for each s in SkipChars do
	M.delta(q,q,λ+s).ignore()
end
end


return M
end

